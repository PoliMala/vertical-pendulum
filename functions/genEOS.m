function [EOS, K, n] = genEOS(problemOpt, varargin)
%%                 [EOS, K, n] = genEOS( problemOpt, ... )
%
% Generates the Equations Of State calculated in the Mathematica notebook 
% in the caller workspace.
%
%   -! in the body function EOS can be modified according to Mathematica
%_________________________________________________________________________ 
% Usage: (linked to 'writeOptions' usage)
%
%   EOS ( function handle @X [EOS(1); ...; EOS(n)] ) = ...
%   ( X -> [X(1); ...; X(n)]      )
%   ( represents the system state )  
%
%       genEOS(problemOpt)        ->  writes EOS ad "EOS" funciton handle
%
%       genEOS(problemOpt, __ )   ->  passing 'writeOptions' arguments
%         i.e.
%           genEOS( problemOpt, range ) 
%           genEOS( problemOpt, optSet ) 
%           genEOS( problemOpt, optName1, optName2, ... )
% 
%       type 'help writeOptions' for more details

%% Function option parsing

if isempty(varargin)
    % default: writes all options and funcName = 
    writeOptions(problemOpt)

elseif or( or(  isequal(class(varargin{1}),'char'), ...
            isequal(class(varargin{1}),'string')  ) ,  ... 
           or(  isequal(class(varargin{1}),'cell'), ...
            isequal(class(varargin{1}),'double')  ) )
    % case: writeOptions arguments passed by argument
    writeOptions(problemOpt, varargin)

else
    error('Incorrect usage, type ''help genEOS'' ')

end

%% Equations Of State

% Thesere equations are copied and pasted from Mathematica notebook
EOS = @(t,X) [        ...
  X(3);               ...
  X(4);               ...
  ...
  ((-1).*m+(-2).*M+m.*cos(2.*X(2))).^(-1).*((-1).*h.*(( ...
  -3)+cos(2.*X(2))).*X(3)+2.*l.*m.*sin(X(2)).*X(4).^2+2.*((-1).*g.* ...
  m.*cos(X(2)).*sin(X(2))+h.^2.*l.*m.^(-2).*M.*X(2)+g.*(m+M).*X(2)+ ...
  3.*domEig.*l.*M.*(domEig.*X(2)+X(4))+g.^(-1).*l.*m.^(-3).*(h+(-1) ...
  .*domEig.*m).^3.*M.*(X(3)+(-1).*l.*X(4))+(-1).*h.*m.^(-1).*(m.*X( ...
  3)+M.*(3.*domEig.*l.*X(2)+(-1).*X(3)+2.*l.*X(4))))); ...
  ...
  g.^(-1).*l.^( ...
  -1).*m.^(-3).*((-1).*m+(-2).*M+m.*cos(2.*X(2))).^(-1).*(g.*m.^2.*( ...
  (-2).*g.*m.*(m+M).*sin(X(2))+(-1).*h.*l.*m.*cos(2.*X(2)).*X(4)+l.* ...
  X(4).*(h.*m+2.*h.*M+m.^2.*sin(2.*X(2)).*X(4)))+2.*cos(X(2)).*( ...
  g.^2.*m.^3.*(m+M).*X(2)+l.*(h+(-1).*domEig.*m).^3.*M.*(X(3)+(-1).* ...
  l.*X(4))+g.*l.*m.*M.*(h.^2.*X(2)+3.*domEig.*m.^2.*(domEig.*X(2)+X( ...
  4))+(-1).*h.*m.*(3.*domEig.*X(2)+2.*X(4)))))];

K = [   0, ...
        (-1).*l.*m.^(-2).*(h.^2+(-3).*domEig.*h.*m+3.*domEig.^2.*m.^2).* ...
        M+(-1).*g.*(m+M), ... 
        h+(-1).*h.*m.^(-1).*M+g.^(-1).*l.*m.^(-3).*((-1).*h+domEig.*m).^3.*M, ...
        g.^(-1).*l.*m.^(-3).*(h.^3.*l+(-3).*domEig.* ...
        h.^2.*l.*m+h.*(2.*g+3.*domEig.^2.*l).*m.^2+(-1).*domEig.*(3.*g+ ...
        domEig.^2.*l).*m.^3).*M  ];

n = length(K);